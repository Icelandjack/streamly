
==================== [0] Initial  ====================
  

-- RHS size: {terms: 38, types: 55, coercions: 0, joins: 0/1}
sourceUnfoldrM
  = \ @ t_ajpZ
      @ m_ajq0
      $dIsStream_ajq2
      $d(%,,%)_ajq3
      eta_B2
      eta_B1 ->
      unfoldrM
        $dIsStream_ajq2
        $d(%,,%)_ajq3
        (let { $dMonad_ajqs = $p1MonadIO ($p1(%,,%) $d(%,,%)_ajq3) } in
         \ cnt_adu6 ->
           case > $fOrdInt cnt_adu6 (+ $fNumInt eta_B1 eta_B2) of {
             False ->
               return $dMonad_ajqs (Just (cnt_adu6, + $fNumInt cnt_adu6 (I# 1#)));
             True -> return $dMonad_ajqs Nothing
           })
        eta_B1

-- RHS size: {terms: 31, types: 50, coercions: 0, joins: 0/0}
benchIOSink
  = \ @ t_ajIH
      @ b_ajII
      $dIsStream_ajIK
      $dNFData_ajIL
      eta_B3
      eta_B2
      eta_B1 ->
      $ (bench eta_B2)
        ($ (nfIO $dNFData_ajIL)
           (>>=
              $fMonadIO
              (randomRIO $fRandomInt (I# 1#, I# 1#))
              (. eta_B1
                 (sourceUnfoldrM
                    $dIsStream_ajIK
                    ($fMonadIOIO, $fMonadBaseControlIOIO, $fMonadThrowIO)
                    eta_B3))))

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
product = \ @ m_ajpE $dMonad_ajpG -> product $dMonad_ajpG $fNumInt

-- RHS size: {terms: 18, types: 15, coercions: 0, joins: 0/0}
main
  = $ (defaultMainWith defaultConfig)
      (build
         (\ @ a_djRq c_djRr n_djRs ->
            c_djRr
              (benchIOSink
                 $fIsStreamSerialT
                 $fNFDataInt
                 (I# 100000#)
                 (unpackCString# "product"#)
                 (product $fMonadIO))
              n_djRs))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
main = runMainIO main

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
$trModule = Module (TrNameS "main"#) (TrNameS "Main"#)


